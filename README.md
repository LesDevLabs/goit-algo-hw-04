[https://www.edu.goit.global/learn/38442047/19646173/19656826/homework

# Порівняння алгоритмів сортування

## Результати тестування
| Розмір | Insertion Sort | Merge Sort | Timsort (вбудований) |
|--------|---------------|------------|---------------------|
| 100    | 0.000196 с    | 0.000105 с | 0.000003 с         |
| 1,000  | 0.018033 с    | 0.001473 с | 0.000041 с         |
| 5,000  | 0.444785 с    | 0.008396 с | 0.000387 с         |
| 10,000 | занадто повільно | 0.018014 с | 0.000848 с      |

## Що ми дізналися?

### Insertion Sort
- Підходить тільки для невеликих масивів (<100 елементів)
- Чим більше даних, тим повільніше працює (квадратична складність O(n²))

### Merge Sort
- Швидкий і стабільний алгоритм
- Добре працює на будь-яких розмірах даних
- Складність O(n log n)

### Timsort (вбудований `sorted()`)
- **Найшвидший** - у 20-35 разів швидший за наш Merge Sort!
- Поєднує переваги Insertion Sort (для малих фрагментів) і Merge Sort (для великих)
- Написаний на C і дуже оптимізований

## Висновок

**Використовуйте завжди вбудовані функції `sorted()` або `.sort()`** - вони набагато швидші, протестовані та надійні.

Власні алгоритми сортування варті писати тільки для навчання або дуже специфічних випадків.
